package com.taptap.router;

import com.google.auto.service.AutoService;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.CodeBlock.Builder;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeSpec;
import com.taptap.RouteConstant;
import com.taptap.annotation.TapRoute;
import java.io.IOException;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.Filer;
import javax.annotation.processing.ProcessingEnvironment;
import javax.annotation.processing.Processor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.Modifier;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.Types;

@AutoService(Processor.class)
@SupportedAnnotationTypes({"com.taptap.annotation.TapRoute"})
@SupportedSourceVersion(SourceVersion.RELEASE_7)
public class RouterProcessor extends AbstractProcessor {

  Filer filer = null;

  Types typeUtils = null;

  /**
   * 页面跳转参数
   */
  private HashMap<Element, List<Element>> pageParams = new HashMap<>();

  @Override
  public synchronized void init(ProcessingEnvironment processingEnvironment) {
    super.init(processingEnvironment);
    filer = processingEnvironment.getFiler();
    typeUtils = processingEnvironment.getTypeUtils();
  }

  @Override
  public Set<String> getSupportedAnnotationTypes() {
    Set<String> set = new HashSet<>();
    set.add(TapRoute.class.getName());
    return set;
  }

  @Override
  public boolean process(Set<? extends TypeElement> set, RoundEnvironment roundEnvironment) {
    if (null == set || set.size() == 0) {
      return false;
    }

    /**
     * 解析Route
     */
    Set<? extends Element> elementsAnnotatedWith = roundEnvironment
        .getElementsAnnotatedWith(TapRoute.class);
    if (null != elementsAnnotatedWith && elementsAnnotatedWith.size() > 0) {
      processElements(elementsAnnotatedWith, roundEnvironment);
      return true;
    }

    return false;
  }

  void processElements(Set<? extends Element> sets, RoundEnvironment roundEnvironment){
    Iterator<? extends Element> iterator = sets.iterator();

    //** type HashMap<String, TapRouter>
    FieldSpec routsFiled = FieldSpec.builder(ParameterizedTypeName.get(Map.class, String.class, RouteData.class)
        , RouteConstant.All_ROUTES_FIELD
        , Modifier.PUBLIC, Modifier.STATIC)
        .initializer(CodeBlock.builder()
            .addStatement("new $T()", ParameterizedTypeName.get(HashMap.class, String.class, RouteData.class))
            .build())
        .build();

    Builder initBuilder = CodeBlock.builder();

    while (iterator.hasNext()) {
      Element next = iterator.next();
      TapRoute annotation = next.getAnnotation(TapRoute.class);
      String path = annotation.path();

      initBuilder.addStatement(RouteConstant.All_ROUTES_FIELD + ".put($S, new $T($N, $S, $T.class))"
          , path
          , RouteData.class
          , Utils.isAndroidActivity(typeUtils, (TypeElement) next)
              ? "com.taptap.router.RouteData.TYPE_ACTIVITY"
              : "com.taptap.router.RouteData.TYPE_OTHERS"
          , path
          , ClassName.get(next.asType()));

    }

    TypeSpec typeSpec = TypeSpec.classBuilder(RouteConstant.All_ROUTES_CLASS)
        .addJavadoc("Auto Generated By TapTap Router! DO NOT MODIFY IT! Created by CaoJianBo")
        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
        .addField(routsFiled)
        .addStaticBlock(initBuilder.build())
        .build();

    JavaFile file = JavaFile.builder(RouteConstant.All_ROUTES_PKG, typeSpec).build();
    try {
      file.writeTo(filer);
    } catch (IOException e) {
      e.printStackTrace();
    }
  }
}
